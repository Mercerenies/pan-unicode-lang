{
  "version": 3,
  "file": "stack_op.js",
  "sourceRoot": "..",
  "sources": [
    "src/stack_op.coffee"
  ],
  "names": [],
  "mappings": ";AACA,IAAA;;AAAA,OAAA;EAAS,OAAT;CAAA,MAAA;;AAmBA,OAAA,IAAO,MAAA,GAAS,QAAA,CAAC,IAAD,EAAO,KAAP,CAAA;AAChB,MAAA,IAAA,EAAA,QAAA,EAAA,UAAA,EAAA,IAAA,EAAA,KAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA;EAAE,CAAC,QAAD,EAAW,KAAX,CAAA,GAAoB,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,CAAlB;EACpB,UAAA,GAAa,KAAK,CAAC,GAAN,CAAU,KAAA,GAAQ,CAAC,QAAA,GAAW,CAAZ,CAAlB;AACb;EAAA,KAAS,sFAAT;IACE,IAAA,GAAO,UAAU,CAAC,KAAX,CAAiB,CAAA,GAAI,QAArB,EAA+B,CAAC,CAAA,GAAI,CAAL,CAAA,GAAU,QAAzC;IACP,IAAA,GAAO,UAAU,CAAC,QAAA,GAAW,KAAX,GAAmB,CAApB;IACjB,KAAK,CAAC,IAAN,CAAW,GAAG,IAAd;iBACA,OAAA,CAAQ,IAAR,EAAc,KAAd;EAJF,CAAA;;AAHc,EAnBhB;;;;;;;;;;;;;;;;AA0CA,OAAA,IAAO,KAAA,GAAQ,QAAA,CAAC,IAAD,EAAO,KAAP,CAAA;AACf,MAAA,CAAA,EAAA,CAAA,EAAA;EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAA,GAAY,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB;SACZ,OAAA,CAAQ,KAAR,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB;AAFa,EA1Cf;;;;;;AAkDA,OAAA,IAAO,KAAA,GAAQ,QAAA,CAAC,IAAD,EAAO,KAAP,CAAA;AACf,MAAA,CAAA,EAAA;EAAE,CAAC,CAAD,EAAI,CAAJ,CAAA,GAAS,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,CAAlB;SACT,OAAA,CAAQ,KAAR,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB;AAFa,EAlDf;;;;;;AA0DA,OAAA,IAAO,MAAA,GAAS,QAAA,CAAC,IAAD,EAAO,KAAP,CAAA;AAChB,MAAA,CAAA,EAAA;EAAE,CAAC,CAAD,EAAI,CAAJ,CAAA,GAAS,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,CAAlB;SACT,OAAA,CAAQ,KAAR,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB;AAFc;;AAIhB,OAAA,GAAU,QAAA,CAAC,KAAD,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,CAAA;AACV,MAAA,IAAA,EAAA,UAAA,EAAA,IAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA;EAAE,UAAA,GAAa,KAAK,CAAC,GAAN,CAAU,CAAA,GAAI,CAAJ,GAAQ,CAAlB;AACb;EAAA,KAAS,kFAAT;IACE,IAAA,GAAO,UAAU,CAAC,CAAA,GAAI,CAAJ,GAAQ,CAAT;;;AACjB;MAAA,KAAS,uFAAT;QACE,IAAA,GAAO,UAAU,CAAC,KAAX,CAAiB,CAAA,GAAI,CAArB,EAAwB,CAAA,GAAI,CAAC,CAAA,GAAI,CAAL,CAA5B;QACP,KAAK,CAAC,IAAN,CAAW,GAAG,IAAd;sBACA,OAAA,CAAQ,IAAR,EAAc,KAAd;MAHF,CAAA;;;EAFF,CAAA;;AAFQ",
  "sourcesContent": [
    "\nimport { tryCall } from './ast.js';\n\n# ⇉ (Spread) takes two numerical arguments. The first (we'll call it\n# A) defaults to 1 and the second (we'll call it F) defaults to 2. F\n# denotes the number of functions, and A denote the number of\n# arguments each function will be given. Spread will pop off F×A\n# values and F functions, for a total of F×(A+1) arguments. Each\n# function will be given A arguments. This is best demonstrated with\n# an example.\n#\n# Examples: Assume a, b, c, ... are values and f, g, h, ... are functions\n#\n# a b f g ⇉ calls f(a) then g(b)\n#\n# a b f g ⇉①② calls f(a) then g(b)\n#\n# a b c f g h ⇉①③ calls f(a) then g(b) then h(c)\n#\n# a b c d f g ⇉②② calls f(a, b) then g(c, d)\nexport spread = (term, state) ->\n  [argsEach, funcs] = term.getNumMod(1, 2)\n  everything = state.pop(funcs * (argsEach + 1))\n  for i in [0..funcs-1]\n    args = everything.slice(i * argsEach, (i + 1) * argsEach)\n    func = everything[argsEach * funcs + i]\n    state.push(...args)\n    tryCall(func, state)\n\n# ⤨ (Cross, an amalgamation of the operators Factor calls apply and\n# cleave) takes three numerical arguments. The first (we'll call it A)\n# defaults to 1, the second (call it B) defaults to 2, and the third\n# (call it F) defaults to 2. A denotes the number of arguments to pass\n# to each call, B denotes the number of groups of arguments, and F\n# denotes the number of functions. This will pop A×B arguments and F\n# functions, for a total of A×B+F values off the stack. For each\n# function and each group of arguments, the function will be called\n# for that group, producing every possible pairing of results in order\n# (function-major ordering).\n#\n# Note: ⤨ is a very general combinator. In many cases, ↘ or ↗ will do\n# what you want with fewer explicit numeric arguments, so consider\n# using those before resorting to this one.\nexport cross = (term, state) ->\n  [a, b, f] = term.getNumMod(1, 2, 2)\n  doCross state, a, b, f\n\n# ↘ (Apply) is ⤨ but with F=1 automatically. Cleave takes two\n# numerical arguments: A and B. A defaults to 1 and B defaults to 2.\n#\n# Mnemonic: We pass several argument groups down to one function.\nexport apply = (term, state) ->\n  [a, b] = term.getNumMod(1, 2)\n  doCross state, a, b, 1\n\n# ↗ (Cleave) is ⤨ but with B=1 automatically. Apply takes two numerical\n# arguments: A and F. A defaults to 1 and F defaults to 2.\n#\n# Mnemonic: We pass a single argument group up to several functions.\nexport cleave = (term, state) ->\n  [a, f] = term.getNumMod(1, 2)\n  doCross state, a, 1, f\n\ndoCross = (state, a, b, f) ->\n  everything = state.pop(a * b + f)\n  for i in [0..f-1]\n    func = everything[a * b + i]\n    for j in [0..b-1]\n      args = everything.slice(a * j, a * (j + 1))\n      state.push(...args)\n      tryCall(func, state)\n"
  ]
}